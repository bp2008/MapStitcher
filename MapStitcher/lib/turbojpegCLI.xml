<?xml version="1.0"?>
<doc>
    <assembly>
        "turbojpegCLI"
    </assembly>
    <members>
        <member name="M:turbojpegCLI.TJCompressor.getCompressedSize">
            <summary>
Returns the size of the image (in bytes) generated by the most recent
compress operation.
</summary>
            <returns>the size of the image (in bytes) generated by the most recent
compress operation.</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.compressToExactSize">
            <summary>
Compress the uncompressed source image associated with this compressor
instance and return a buffer containing a JPEG image. This method copies
the compressed data to a new array of the appropriate size, so you do not
have to call getCompressedSize() or deal with passing around the actual
compressed length separately from the byte array.  Consequently, this method
is a little less efficient than the other compress methods, and it creates
more garbage for the garbage collector.
</summary>
            <returns>a buffer containing a JPEG image. The length of this buffer will be 
equal to the size of the JPEG image.</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.compressToExactSize(turbojpegCLI.Flag)">
            <summary>
Compress the uncompressed source image associated with this compressor
instance and return a buffer containing a JPEG image. This method copies
the compressed data to a new array of the appropriate size, so you do not
have to call getCompressedSize() or deal with passing around the actual
compressed length separately from the byte array.  Consequently, this method
is a little less efficient than the other compress methods, and it creates
more garbage for the garbage collector.
</summary>
            <param name="flags">the bitwise OR of one or more of the Flag enum values</param>
            <returns>a buffer containing a JPEG image. The length of this buffer will be 
equal to the size of the JPEG image.</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.compress">
            <summary>
Compress the uncompressed source image associated with this compressor
instance and return a buffer containing a JPEG image. The length of this 
buffer will not be equal to the size of the JPEG image. Use 
getCompressedSize() to obtain the size of the JPEG image.
</summary>
            <returns>a buffer containing a JPEG image.  The length of this buffer will
not be equal to the size of the JPEG image.  Use getCompressedSize() to
obtain the size of the JPEG image.</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.compress(turbojpegCLI.Flag)">
            <summary>
Compress the uncompressed source image associated with this compressor
instance and return a buffer containing a JPEG image. The length of this 
buffer will not be equal to the size of the JPEG image. Use 
getCompressedSize() to obtain the size of the JPEG image.
</summary>
            <param name="flags">the bitwise OR of one or more of the Flag enum values</param>
            <returns>a buffer containing a JPEG image.  The length of this buffer will
not be equal to the size of the JPEG image.  Use getCompressedSize() to
obtain the size of the JPEG image.</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.compress(System.Byte[]@,turbojpegCLI.Flag)">
            <summary>
Compress the uncompressed source image associated with this compressor
instance and output a JPEG image to the given destination buffer.
</summary>
            <param name="dstBuf">buffer that will receive the JPEG image.  Use
TJ.bufSize() to determine the maximum size for this buffer based on
the source image's width and height and the desired level of chrominance
subsampling. Although it is unlikely, libjpeg-turbo may replace this 
buffer so it must be passed by reference.</param>
            <param name="flags">the bitwise OR of one or more of the Flag enum values</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.getJPEGQuality">
            <summary>
Get the JPEG image quality level being used for subsequent compress operations. (1 to 100, 1 = worst,
100 = best)  Default value if unset: 80
</summary>
            <returns>the JPEG image quality level (1 to 100, 1 = worst,
100 = best)</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.setJPEGQuality(System.Int32)">
            <summary>
Set the JPEG image quality level for subsequent compress operations.
</summary>
            <param name="quality">the new JPEG image quality level (1 to 100, 1 = worst,
100 = best)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.getSubsamp">
            <summary>
                <para>Get the level of chrominance subsampling being used for subsequent compress/encode
operations.</para>
                <para>Default value if unset: SubsamplingOption.SAMP_420</para>
            </summary>
            <returns>the level of chrominance subsampling being used for subsequent compress/encode
operations. Default value if unset: SubsamplingOption.SAMP_420</returns>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.setSubsamp(turbojpegCLI.SubsamplingOption)">
            <summary>
Set the level of chrominance subsampling for subsequent compress/encode
operations.  When pixels are converted from RGB to YCbCr (see
Colorspace.YCbCr) or from CMYK to YCCK (see Colorspace.YCCK) as part
of the JPEG compression process, some of the Cb and Cr (chrominance)
components can be discarded or averaged together to produce a smaller
image with little perceptible loss of image clarity (the human eye is more
sensitive to small changes in brightness than to small changes in color.)
This is called "chrominance subsampling".
</summary>
            <param name="newSubsamp">the level of chrominance subsampling to use in
subsequent compress/encode oeprations (one of the
SubsamplingOption enum values)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.setSourceImage(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,turbojpegCLI.PixelFormat)">
            <summary>
Associate an uncompressed RGB, grayscale, or CMYK source image with this
compressor instance.
</summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="x">x offset (in pixels) of the region in the source image from which
the JPEG or YUV image should be compressed/encoded</param>
            <param name="y">y offset (in pixels) of the region in the source image from which
the JPEG or YUV image should be compressed/encoded</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pitch">bytes per line of the source image.  Normally, this should be
<code>width * TJ.getPixelSize(pixelFormat)</code> if the source image is
unpadded, but you can use this parameter to, for instance, specify that
the scanlines in the source image are padded to a 4-byte boundary or to
compress/encode a JPEG or YUV image from a region of a larger source
image.  You can also be clever and use this parameter to skip lines, etc.
Setting this parameter to 0 is the equivalent of setting it to
<code>width * TJ.getPixelSize(pixelFormat)</code>.</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pixelFormat">pixel format of the source image (one of the PixelFormat enum values)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.setSourceImage(System.Byte[],System.Int32,System.Int32,turbojpegCLI.PixelFormat)">
            <summary>
                <para>Associate an uncompressed RGB, grayscale, or CMYK source image with this
compressor instance.</para>
                <para>The image is assumed to be unpadded.</para>
            </summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pixelFormat">pixel format of the source image (one of the PixelFormat enum values)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.setSourceImage(System.Byte[],System.Int32,System.Int32)">
            <summary>
                <para>Associate an uncompressed RGB image with this compressor instance.</para>
                <para>The image is assumed to have a standard RGB pixel format.</para>
            </summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.#ctor(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,turbojpegCLI.PixelFormat)">
            <summary>
                <para>Create a TurboJPEG compressor instance and associate the uncompressed
source image stored in <code>srcImage</code> with the newly created
instance.</para>
                <para>The default SubsamplingOption will be SubsamplingOption.SAMP_420.</para>
                <para>The default JPEG Quality will be 80 (range: 1 to 100)</para>
            </summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="x">x offset (in pixels) of the region in the source image from which
the JPEG or YUV image should be compressed/encoded</param>
            <param name="y">y offset (in pixels) of the region in the source image from which
the JPEG or YUV image should be compressed/encoded</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pitch">bytes per line of the source image.  Normally, this should be
<code>width * TJ.getPixelSize(pixelFormat)</code> if the source image is
unpadded, but you can use this parameter to, for instance, specify that
the scanlines in the source image are padded to a 4-byte boundary or to
compress/encode a JPEG or YUV image from a region of a larger source
image.  You can also be clever and use this parameter to skip lines, etc.
Setting this parameter to 0 is the equivalent of setting it to
<code>width * TJ.getPixelSize(pixelFormat)</code>.</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pixelFormat">pixel format of the source image (one of the PixelFormat enum values)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.#ctor(System.Byte[],System.Int32,System.Int32,turbojpegCLI.PixelFormat)">
            <summary>
                <para>Create a TurboJPEG compressor instance and associate the uncompressed
source image stored in <code>srcImage</code> with the newly created
instance.</para>
                <para>The image is assumed to be unpadded.</para>
                <para>The default SubsamplingOption will be SubsamplingOption.SAMP_420.</para>
                <para>The default JPEG Quality will be 80 (range: 1 to 100)</para>
            </summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="pixelFormat">pixel format of the source image (one of the PixelFormat enum values)</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>
                <para>Create a TurboJPEG compressor instance and associate the uncompressed
source image stored in <code>srcImage</code> with the newly created
instance.</para>
                <para>The image is assumed to have a standard RGB pixel format.</para>
                <para>The default SubsamplingOption will be SubsamplingOption.SAMP_420.</para>
                <para>The default JPEG Quality will be 80 (range: 1 to 100)</para>
            </summary>
            <param name="srcImage">image buffer containing RGB, grayscale, or CMYK pixels to
be compressed or encoded.  This buffer is not modified.</param>
            <param name="width">width (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
            <param name="height">height (in pixels) of the region in the source image from
which the JPEG or YUV image should be compressed/encoded</param>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.Dispose">
            <summary>
Call this when finished with the TJDecompressor to free any native structures.
If you use a C# using() block, you won't need to call this.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJCompressor.#ctor">
            <summary>
                <para>Create a TurboJPEG compressor instance that can not be used until setSourceImage(...) is called.</para>
                <para>The default SubsamplingOption will be SubsamplingOption.SAMP_420.</para>
                <para>The default JPEG Quality will be 80 (range: 1 to 100)</para>
            </summary>
        </member>
        <member name="T:turbojpegCLI.TJCompressor">
            <summary>
TurboJPEG compressor
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress">
            <summary>
Decompress the JPEG source image associated with this decompressor
instance and return a new buffer containing the decompressed image.
The image is decompressed to its native resolution using the standard 
RGB format.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress(turbojpegCLI.PixelFormat,turbojpegCLI.Flag)">
            <summary>
Decompress the JPEG source image associated with this decompressor
instance and return a new buffer containing the decompressed image.
The image is decompressed to its native resolution.
</summary>
            <param name="pixelFormat">pixel format of the decompressed/decoded image (one of
the turbojpegCLI.PixelFormat enum values)</param>
            <param name="flags">the bitwise OR of one or more of
the turbojpegCLI.Flag enum values</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress(System.Int32,System.Int32,System.Int32,turbojpegCLI.PixelFormat,turbojpegCLI.Flag)">
            <summary>
Decompress the JPEG source image associated with this decompressor
instance and return a new buffer containing the decompressed image.
</summary>
            <param name="desiredWidth">If the source image is a JPEG image, then this
specifies the desired width (in pixels) of the decompressed image (or
image region.)  If the desired destination image dimensions are different
than the source image dimensions, then TurboJPEG will use scaling in the
JPEG decompressor to generate the largest possible image that will fit
within the desired dimensions.  Setting this to 0 is the same as setting
it to the width of the JPEG image (in other words, the width will not be
considered when determining the scaled image size.)  This parameter is
ignored if the source image is a YUV image.</param>
            <param name="pitch">bytes per line of the destination image.  Normally, this
should be set to <code>scaledWidth * TJ.getPixelSize(pixelFormat)</code> if
the destination image is unpadded, but you can use this to, for instance,
pad each line of the destination image to a 4-byte boundary or to
decompress/decode the source image into a region of a larger image.  NOTE:
if the source image is a JPEG image, then <code>scaledWidth</code> can be
determined by calling <code>TJScalingFactor.getScaled(jpegWidth)</code> 
or by calling this.getScaledWidth().  If the source image is a
YUV image, then <code>scaledWidth</code> is the width of the YUV image.
Setting this parameter to 0 is the equivalent of setting it to
<code>scaledWidth * TJ.getPixelSize(pixelFormat)</code>.</param>
            <param name="desiredHeight">If the source image is a JPEG image, then this
specifies the desired height (in pixels) of the decompressed image (or
image region.)  If the desired destination image dimensions are different
than the source image dimensions, then TurboJPEG will use scaling in the
JPEG decompressor to generate the largest possible image that will fit
within the desired dimensions.  Setting this to 0 is the same as setting
it to the height of the JPEG image (in other words, the height will not be
considered when determining the scaled image size.)  This parameter is
ignored if the source image is a YUV image.</param>
            <param name="pixelFormat">pixel format of the decompressed/decoded image (one of
the turbojpegCLI.PixelFormat enum values)</param>
            <param name="flags">the bitwise OR of one or more of
the turbojpegCLI.Flag enum values</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress(System.Byte[])">
            <summary>
Decompress the JPEG source image or decode the YUV source image associated
with this decompressor instance and output a grayscale, RGB, or CMYK image
to the given destination buffer. 
The image is decompressed to its native resolution using the standard 
RGB format.
(NOTE: YUV source images are not currently supported by this wrapper)
</summary>
            <param name="dstBuf">buffer that will receive the decompressed/decoded image.
If the source image is a JPEG image, then this buffer should normally be
<code>pitch * scaledHeight</code> bytes in size, where
<code>scaledHeight</code> can be determined by calling <code>
scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegHeight)
</code> with one of the scaling factors returned from {@link
TJ#getScalingFactors} or by calling {@link #getScaledHeight}.  If the
source image is a YUV image, then this buffer should normally be
<code>pitch * height</code> bytes in size, where <code>height</code> is
the height of the YUV image.  However, the buffer may also be larger than
the dimensions of the source image, in which case the <code>x</code>,
<code>y</code>, and <code>pitch</code> parameters can be used to specify
the region into which the source image should be decompressed/decoded.</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress(System.Byte[],turbojpegCLI.PixelFormat,turbojpegCLI.Flag)">
            <summary>
Decompress the JPEG source image or decode the YUV source image associated
with this decompressor instance and output a grayscale, RGB, or CMYK image
to the given destination buffer. 
The image is decompressed to its native resolution.
(NOTE: YUV source images are not currently supported by this wrapper)
</summary>
            <param name="dstBuf">buffer that will receive the decompressed/decoded image.
If the source image is a JPEG image, then this buffer should normally be
<code>pitch * scaledHeight</code> bytes in size, where
<code>scaledHeight</code> can be determined by calling <code>
scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegHeight)
</code> with one of the scaling factors returned from {@link
TJ#getScalingFactors} or by calling {@link #getScaledHeight}.  If the
source image is a YUV image, then this buffer should normally be
<code>pitch * height</code> bytes in size, where <code>height</code> is
the height of the YUV image.  However, the buffer may also be larger than
the dimensions of the source image, in which case the <code>x</code>,
<code>y</code>, and <code>pitch</code> parameters can be used to specify
the region into which the source image should be decompressed/decoded.</param>
            <param name="pixelFormat">pixel format of the decompressed/decoded image (one of
the turbojpegCLI.PixelFormat enum values)</param>
            <param name="flags">the bitwise OR of one or more of
the turbojpegCLI.Flag enum values</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.decompress(System.Byte[],System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,turbojpegCLI.PixelFormat,turbojpegCLI.Flag)">
            <summary>
Decompress the JPEG source image or decode the YUV source image associated
with this decompressor instance and output a grayscale, RGB, or CMYK image
to the given destination buffer.
(NOTE: YUV source images are not currently supported by this wrapper)
</summary>
            <param name="dstBuf">buffer that will receive the decompressed/decoded image.
If the source image is a JPEG image, then this buffer should normally be
<code>pitch * scaledHeight</code> bytes in size, where
<code>scaledHeight</code> can be determined by calling <code>
scalingFactor.{@link TJScalingFactor#getScaled getScaled}(jpegHeight)
</code> with one of the scaling factors returned from {@link
TJ#getScalingFactors} or by calling {@link #getScaledHeight}.  If the
source image is a YUV image, then this buffer should normally be
<code>pitch * height</code> bytes in size, where <code>height</code> is
the height of the YUV image.  However, the buffer may also be larger than
the dimensions of the source image, in which case the <code>x</code>,
<code>y</code>, and <code>pitch</code> parameters can be used to specify
the region into which the source image should be decompressed/decoded.</param>
            <param name="x">x offset (in pixels) of the region in the destination image into
which the source image should be decompressed/decoded. Usually you want this to be 0.</param>
            <param name="y">y offset (in pixels) of the region in the destination image into
which the source image should be decompressed/decoded. Usually you want this to be 0.</param>
            <param name="desiredWidth">If the source image is a JPEG image, then this
specifies the desired width (in pixels) of the decompressed image (or
image region.)  If the desired destination image dimensions are different
than the source image dimensions, then TurboJPEG will use scaling in the
JPEG decompressor to generate the largest possible image that will fit
within the desired dimensions.  Setting this to 0 is the same as setting
it to the width of the JPEG image (in other words, the width will not be
considered when determining the scaled image size.)  This parameter is
ignored if the source image is a YUV image.</param>
            <param name="pitch">bytes per line of the destination image.  Normally, this
should be set to <code>scaledWidth * TJ.getPixelSize(pixelFormat)</code> if
the destination image is unpadded, but you can use this to, for instance,
pad each line of the destination image to a 4-byte boundary or to
decompress/decode the source image into a region of a larger image.  NOTE:
if the source image is a JPEG image, then <code>scaledWidth</code> can be
determined by calling <code>TJScalingFactor.getScaled(jpegWidth)</code> 
or by calling this.getScaledWidth().  If the source image is a
YUV image, then <code>scaledWidth</code> is the width of the YUV image.
Setting this parameter to 0 is the equivalent of setting it to
<code>scaledWidth * TJ.getPixelSize(pixelFormat)</code>.</param>
            <param name="desiredHeight">If the source image is a JPEG image, then this
specifies the desired height (in pixels) of the decompressed image (or
image region.)  If the desired destination image dimensions are different
than the source image dimensions, then TurboJPEG will use scaling in the
JPEG decompressor to generate the largest possible image that will fit
within the desired dimensions.  Setting this to 0 is the same as setting
it to the height of the JPEG image (in other words, the height will not be
considered when determining the scaled image size.)  This parameter is
ignored if the source image is a YUV image.</param>
            <param name="pixelFormat">pixel format of the decompressed/decoded image (one of
the turbojpegCLI.PixelFormat enum values)</param>
            <param name="flags">the bitwise OR of one or more of
the turbojpegCLI.Flag enum values</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getScaledHeight(System.Int32,System.Int32)">
            <summary>
Returns the height of the largest scaled-down image that the TurboJPEG
decompressor can generate without exceeding the desired image width and
height.
</summary>
            <param name="desiredWidth">desired width (in pixels) of the decompressed image.
Setting this to 0 is the same as setting it to the width of the JPEG image
(in other words, the width will not be considered when determining the
scaled image size.)</param>
            <param name="desiredHeight">desired height (in pixels) of the decompressed image.
Setting this to 0 is the same as setting it to the height of the JPEG
image (in other words, the height will not be considered when determining
the scaled image size.)</param>
            <returns>the height of the largest scaled-down image that the TurboJPEG
decompressor can generate without exceeding the desired image width and
height.</returns>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getScaledWidth(System.Int32,System.Int32)">
            <summary>
Returns the width of the largest scaled-down image that the TurboJPEG
decompressor can generate without exceeding the desired image width and
height.
</summary>
            <param name="desiredWidth">desired width (in pixels) of the decompressed image.
Setting this to 0 is the same as setting it to the width of the JPEG image
(in other words, the width will not be considered when determining the
scaled image size.)</param>
            <param name="desiredHeight">desired height (in pixels) of the decompressed image.
Setting this to 0 is the same as setting it to the height of the JPEG
image (in other words, the height will not be considered when determining
the scaled image size.)</param>
            <returns>the width of the largest scaled-down image that the TurboJPEG
decompressor can generate without exceeding the desired image width and
height.</returns>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getJPEGSize">
            <summary>
Gets the image size in bytes last assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getJPEGBuf">
            <summary>
Gets the byte array last assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getColorspace">
            <summary>
Gets the Colorspace of the last image assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getSubsamp">
            <summary>
Gets the subsampling mode of the last image assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getHeight">
            <summary>
Gets the height in pixels of the last image assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.getWidth">
            <summary>
Gets the width in pixels of the last image assigned to this instance. You may call this any time after setting the source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.setSourceImage(System.Byte[],System.Int32)">
            <summary>
Associate the JPEG image of length <code>imageSize</code> bytes stored in
<code>jpegImage</code> with this decompressor instance. This image will
be used as the source image for subsequent decompress operations.
</summary>
            <param name="jpegImage">A byte array containing compressed jpeg image data.</param>
            <param name="imageSize">The length of the image data in the array.</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.Dispose">
            <summary>
Call this when finished with the TJDecompressor to free any native structures.
If you use a C# using() block, you won't need to call this.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.#ctor(System.Byte[],System.Int32)">
            <summary>
Constructs a TJDecompressor which is responsible for decompressing a jpeg image.
</summary>
            <param name="jpegImage">A byte array containing compressed jpeg image data.</param>
            <param name="imageSize">The length of the image data in the array.</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.#ctor(System.Byte[])">
            <summary>
Constructs a TJDecompressor which is responsible for decompressing a jpeg image.
</summary>
            <param name="jpegImage">A byte array containing compressed jpeg image data.</param>
        </member>
        <member name="M:turbojpegCLI.TJDecompressor.#ctor">
            <summary>
Constructs a TJDecompressor which is responsible for decompressing a jpeg image.
When using the parameterless constructor, you must call setSourceImage().
</summary>
        </member>
        <member name="T:turbojpegCLI.TJDecompressor">
            <summary>
TurboJPEG decompressor
</summary>
        </member>
        <member name="M:turbojpegCLI.TJ.getScalingFactors">
            <summary>
Returns a list of fractional scaling factors that the JPEG decompressor in
this implementation of TurboJPEG supports.
</summary>
            <returns>a list of fractional scaling factors that the JPEG decompressor in
this implementation of TurboJPEG supports.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.bufSize(System.Int32,System.Int32,turbojpegCLI.SubsamplingOption)">
            <summary>
Returns the maximum size of the buffer (in bytes) required to hold a JPEG
image with the given width, height, and level of chrominance subsampling.
</summary>
            <param name="width">the width (in pixels) of the JPEG image</param>
            <param name="height">the height (in pixels) of the JPEG image</param>
            <param name="jpegSubsamp">the level of chrominance subsampling to be used when
generating the JPEG image (one of SubsamplingOption enum values)</param>
            <returns>the maximum size of the buffer (in bytes) required to hold a JPEG
image with the given width, height, and level of chrominance subsampling.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getBlueOffset(turbojpegCLI.PixelFormat)">
            <summary>
For the given pixel format, returns the number of bytes that the blue
component is offset from the start of the pixel.  For instance, if a pixel
of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
then the blue component will be
<code>pixel[TJ.getBlueOffset(TJ.PF_BGRX)]</code>.
</summary>
            <param name="pixelFormat">the pixel format (one of <code>PixelFormat</code> enum values)</param>
            <returns>the blue offset for the given pixel format.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getGreenOffset(turbojpegCLI.PixelFormat)">
            <summary>
For the given pixel format, returns the number of bytes that the green
component is offset from the start of the pixel.  For instance, if a pixel
of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
then the green component will be
<code>pixel[TJ.getGreenOffset(TJ.PF_BGRX)]</code>.
</summary>
            <param name="pixelFormat">the pixel format (one of <code>PixelFormat</code> enum values)</param>
            <returns>the green offset for the given pixel format.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getRedOffset(turbojpegCLI.PixelFormat)">
            <summary>
For the given pixel format, returns the number of bytes that the red
component is offset from the start of the pixel.  For instance, if a pixel
of format <code>TJ.PF_BGRX</code> is stored in <code>char pixel[]</code>,
then the red component will be
<code>pixel[TJ.getRedOffset(TJ.PF_BGRX)]</code>.
</summary>
            <param name="pixelFormat">the pixel format (one of <code>PixelFormat</code> enum values)</param>
            <returns>the red offset for the given pixel format.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getPixelSize(turbojpegCLI.PixelFormat)">
            <summary>
Returns the pixel size (in bytes) for the given pixel format.
</summary>
            <param name="pixelFormat">the pixel format (one of <code>PixelFormat</code> enum values)</param>
            <returns>the pixel size (in bytes) for the given pixel format.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getMCUHeight(turbojpegCLI.SubsamplingOption)">
            <summary>
Returns the MCU block height for the given level of chrominance
subsampling.
</summary>
            <param name="subsamp">the level of chrominance subsampling (one of
<code>SAMP_*</code>)</param>
            <returns>the MCU block height for the given level of chrominance
subsampling.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.getMCUWidth(turbojpegCLI.SubsamplingOption)">
            <summary>
Returns the MCU block width for the given level of chrominance
subsampling.
</summary>
            <param name="subsamp">the level of chrominance subsampling (one of
<code>SubsamplingOption</code> enum values)</param>
            <returns>the MCU block width for the given level of chrominance
subsampling.</returns>
        </member>
        <member name="M:turbojpegCLI.TJ.isValidPixelFormat(turbojpegCLI.PixelFormat)">
            <summary>
Returns false if the specified PixelFormat is invalid.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJ.isValidSubsampling(turbojpegCLI.SubsamplingOption)">
            <summary>
Returns false if the specified SubsamplingOption is invalid.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJ.checkPixelFormat(turbojpegCLI.PixelFormat)">
            <summary>
Throws an exception if the specified PixelFormat is invalid.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJ.checkSubsampling(turbojpegCLI.SubsamplingOption)">
            <summary>
Throws an exception if the specified SubsamplingOption is invalid.
</summary>
        </member>
        <member name="F:turbojpegCLI.TJ.NUMPF">
            <summary>
The number of pixel formats
</summary>
        </member>
        <member name="F:turbojpegCLI.TJ.NUMCS">
            <summary>
The number of JPEG colorspaces
</summary>
        </member>
        <member name="F:turbojpegCLI.TJ.NUMSAMP">
            <summary>
The number of chrominance subsampling options
</summary>
        </member>
        <member name="F:turbojpegCLI.Flag.ACCURATEDCT">
            <summary>
Use the most accurate DCT/IDCT algorithm available in the underlying
codec.  The default if this flag is not specified is
implementation-specific.  For example, the implementation of TurboJPEG for
libjpeg[-turbo] uses the fast algorithm by default when compressing,
because this has been shown to have only a very slight effect on accuracy,
but it uses the accurate algorithm when decompressing, because this has
been shown to have a larger effect.
</summary>
        </member>
        <member name="F:turbojpegCLI.Flag.FASTDCT">
            <summary>
Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
default if this flag is not specified is implementation-specific.  For
example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
algorithm by default when compressing, because this has been shown to have
only a very slight effect on accuracy, but it uses the accurate algorithm
when decompressing, because this has been shown to have a larger effect.
</summary>
        </member>
        <member name="F:turbojpegCLI.Flag.FASTUPSAMPLE">
            <summary>
When decompressing an image that was compressed using chrominance
subsampling, use the fastest chrominance upsampling algorithm available in
the underlying codec.  The default is to use smooth upsampling, which
creates a smooth transition between neighboring chrominance components in
order to reduce upsampling artifacts in the decompressed image.
</summary>
        </member>
        <member name="F:turbojpegCLI.Flag.BOTTOMUP">
            <summary>
The uncompressed source/destination image is stored in bottom-up (Windows,
OpenGL) order, not top-down (X11) order.
</summary>
        </member>
        <member name="F:turbojpegCLI.Flag.NONE">
            <summary>
A flag specifying no flags are to be used. This is equivalent to the integer 0.
</summary>
        </member>
        <member name="F:turbojpegCLI.Colorspace.YCCK">
            <summary>
YCCK colorspace.  YCCK (AKA "YCbCrK") is not an absolute colorspace but
rather a mathematical transformation of CMYK designed solely for storage
and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be
reversibly transformed into YCCK, and as with YCbCr, the chrominance
components in the YCCK pixels can be subsampled without incurring major
perceptual loss.  YCCK JPEG images can only be compressed from and
decompressed to CMYK pixels.
</summary>
        </member>
        <member name="F:turbojpegCLI.Colorspace.CMYK">
            <summary>
CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
components in the source image are reordered into image planes, but no
colorspace conversion or subsampling is performed.  CMYK JPEG images can
only be decompressed to CMYK pixels.
</summary>
        </member>
        <member name="F:turbojpegCLI.Colorspace.GRAY">
            <summary>
Grayscale colorspace.  The JPEG image retains only the luminance data (Y
component), and any color data from the source image is discarded.
Grayscale JPEG images can be compressed from and decompressed to any of
the extended RGB pixel formats or grayscale, or they can be decompressed
to YUV planar images.
</summary>
        </member>
        <member name="F:turbojpegCLI.Colorspace.YCbCr">
            <summary>
YCbCr colorspace.  YCbCr is not an absolute colorspace but rather a
mathematical transformation of RGB designed solely for storage and
transmission.  YCbCr images must be converted to RGB before they can
actually be displayed.  In the YCbCr colorspace, the Y (luminance)
component represents the black &amp; white portion of the original image, and
the Cb and Cr (chrominance) components represent the color portion of the
original image.  Originally, the analog equivalent of this transformation
allowed the same signal to drive both black &amp; white and color televisions,
but JPEG images use YCbCr primarily because it allows the color data to be
optionally subsampled for the purposes of reducing bandwidth or disk
space.  YCbCr is the most common JPEG colorspace, and YCbCr JPEG images
can be compressed from and decompressed to any of the extended RGB pixel
formats or grayscale, or they can be decompressed to YUV planar images.
</summary>
        </member>
        <member name="F:turbojpegCLI.Colorspace.RGB">
            <summary>
RGB colorspace.  When compressing the JPEG image, the R, G, and B
components in the source image are reordered into image planes, but no
colorspace conversion or subsampling is performed.  RGB JPEG images can be
decompressed to any of the extended RGB pixel formats or grayscale, but
they cannot be decompressed to YUV images.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.CMYK">
            <summary>
CMYK pixel format.  Unlike RGB, which is an additive color model used
primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
color model used primarily for printing.  In the CMYK color model, the
value of each color component typically corresponds to an amount of cyan,
magenta, yellow, or black ink that is applied to a white background.  In
order to convert between CMYK and RGB, it is necessary to use a color
management system (CMS.)  A CMS will attempt to map colors within the
printer's gamut to perceptually similar colors in the display's gamut and
vice versa, but the mapping is typically not 1:1 or reversible, nor can it
be defined with a simple formula.  Thus, such a conversion is out of scope
for a codec library.  However, the TurboJPEG API allows for compressing
CMYK pixels into a YCCK JPEG image (see {@link #CS_YCCK}) and
decompressing YCCK JPEG images into CMYK pixels.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.ARGB">
            <summary>
ARGB pixel format.  This is the same as {@link #PF_XRGB}, except that when
decompressing, the X byte is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.ABGR">
            <summary>
ABGR pixel format.  This is the same as {@link #PF_XBGR}, except that when
decompressing, the X byte is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.BGRA">
            <summary>
BGRA pixel format.  This is the same as {@link #PF_BGRX}, except that when
decompressing, the X byte is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.RGBA">
            <summary>
RGBA pixel format.  This is the same as {@link #PF_RGBX}, except that when
decompressing, the X byte is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.GRAY">
            <summary>
Grayscale pixel format.  Each 1-byte pixel represents a luminance
(brightness) level from 0 to 255.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.XRGB">
            <summary>
XRGB pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order B, G, R from highest to lowest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.XBGR">
            <summary>
XBGR pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order R, G, B from highest to lowest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.BGRX">
            <summary>
BGRX pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order B, G, R from lowest to highest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.RGBX">
            <summary>
RGBX pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order R, G, B from lowest to highest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.BGR">
            <summary>
BGR pixel format.  The red, green, and blue components in the image are
stored in 3-byte pixels in the order B, G, R from lowest to highest byte
address within each pixel.
</summary>
        </member>
        <member name="F:turbojpegCLI.PixelFormat.RGB">
            <summary>
RGB pixel format.  The red, green, and blue components in the image are
stored in 3-byte pixels in the order R, G, B from lowest to highest byte
address within each pixel.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_411">
            <summary>
4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 4x1 block of pixels in the source image.
JPEG images compressed with 4:1:1 subsampling will be almost exactly the
same size as those compressed with 4:2:0 subsampling, and in the
aggregate, both subsampling methods produce approximately the same
perceptual quality.  However, 4:1:1 is better able to reproduce sharp
horizontal features.  Note that 4:1:1 subsampling is not fully accelerated
in libjpeg-turbo.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_440">
            <summary>
4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 1x2 block of pixels in the source image.
Note that 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_GRAY">
            <summary>
Grayscale.  The JPEG or YUV image will contain no chrominance components.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_420">
            <summary>
4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 2x2 block of pixels in the source image.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_422">
            <summary>
4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 2x1 block of pixels in the source image.
</summary>
        </member>
        <member name="F:turbojpegCLI.SubsamplingOption.SAMP_444">
            <summary>
4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG
or YUV image will contain one chrominance component for every pixel in the
source image.
</summary>
        </member>
        <member name="M:turbojpegCLI.TJScalingFactor.isOne">
            <summary>
Returns true or false, depending on whether this instance is equal to
1/1.
</summary>
            <returns>true or false, depending on whether this instance is equal to
1/1.</returns>
        </member>
        <member name="M:turbojpegCLI.TJScalingFactor.equals(turbojpegCLI.TJScalingFactor!System.Runtime.CompilerServices.IsByValue)">
            <summary>
Returns true or false, depending on whether this instance and
<code>other</code> have the same numerator and denominator.
</summary>
            <returns>true or false, depending on whether this instance and
<code>other</code> have the same numerator and denominator.</returns>
        </member>
        <member name="M:turbojpegCLI.TJScalingFactor.getScaled(System.Int32)">
            <summary>
Returns the scaled value of <code>dimension</code>.  This function
performs the integer equivalent of
<code>ceil(dimension * scalingFactor)</code>.
</summary>
            <returns>the scaled value of <code>dimension</code>.</returns>
        </member>
        <member name="M:turbojpegCLI.TJScalingFactor.getDenom">
            <summary>
Returns denominator
</summary>
        </member>
        <member name="M:turbojpegCLI.TJScalingFactor.getNum">
            <summary>
Returns numerator
</summary>
        </member>
        <member name="F:turbojpegCLI.TJScalingFactor.denom">
            <summary>
Denominator
</summary>
        </member>
        <member name="F:turbojpegCLI.TJScalingFactor.num">
            <summary>
Numerator
</summary>
        </member>
        <member name="M:tjGetErrorStr">
 Returns a descriptive error message explaining why the last command failed.

 @return a descriptive error message explaining why the last command failed.

</member>
        <member name="M:tjFree(System.Byte*)">
 Free an image buffer previously allocated by TurboJPEG.  You should always
 use this function to free JPEG destination buffer(s) that were automatically
 (re)allocated by #tjCompress2() or #tjTransform() or that were manually
 allocated using #tjAlloc().

 @param buffer address of the buffer to free

 @sa tjAlloc()

</member>
        <member name="M:tjAlloc(System.Int32)">
 Allocate an image buffer for use with TurboJPEG.  You should always use
 this function to allocate the JPEG destination buffer(s) for #tjCompress2()
 and #tjTransform() unless you are disabling automatic buffer
 (re)allocation (by setting #TJFLAG_NOREALLOC.)

 @param bytes the number of bytes to allocate

 @return a pointer to a newly-allocated buffer with the specified number of
 bytes.

 @sa tjFree()

</member>
        <member name="M:tjDestroy(System.Void*)">
 Destroy a TurboJPEG compressor, decompressor, or transformer instance.

 @param handle a handle to a TurboJPEG compressor, decompressor or
 transformer instance

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjTransform(System.Void*,System.Byte*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32,System.Byte**,System.UInt32!System.Runtime.CompilerServices.IsLong*,tjtransform*,System.Int32)">
 Losslessly transform a JPEG image into another JPEG image.  Lossless
 transforms work by moving the raw DCT coefficients from one JPEG image
 structure to another without altering the values of the coefficients.  While
 this is typically faster than decompressing the image, transforming it, and
 re-compressing it, lossless transforms are not free.  Each lossless
 transform requires reading and performing Huffman decoding on all of the
 coefficients in the source image, regardless of the size of the destination
 image.  Thus, this function provides a means of generating multiple
 transformed images from the same source or  applying multiple
 transformations simultaneously, in order to eliminate the need to read the
 source coefficients multiple times.

 @param handle a handle to a TurboJPEG transformer instance

 @param jpegBuf pointer to a buffer containing the JPEG source image to
 transform.  This buffer is not modified.

 @param jpegSize size of the JPEG source image (in bytes)

 @param n the number of transformed JPEG images to generate

 @param dstBufs pointer to an array of n image buffers.  <tt>dstBufs[i]</tt>
 will receive a JPEG image that has been transformed using the parameters in
 <tt>transforms[i]</tt>.  TurboJPEG has the ability to reallocate the JPEG
 buffer to accommodate the size of the JPEG image.  Thus, you can choose to:
 -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
 let TurboJPEG grow the buffer as needed,
 -# set <tt>dstBufs[i]</tt> to NULL to tell TurboJPEG to allocate the buffer
 for you, or
 -# pre-allocate the buffer to a "worst case" size determined by calling
 #tjBufSize() with the transformed or cropped width and height.  This should
 ensure that the buffer never has to be re-allocated (setting
 #TJFLAG_NOREALLOC guarantees this.)
 .
 If you choose option 1, <tt>dstSizes[i]</tt> should be set to the size of
 your pre-allocated buffer.  In any case, unless you have set
 #TJFLAG_NOREALLOC, you should always check <tt>dstBufs[i]</tt> upon return
 from this function, as it may have changed.

 @param dstSizes pointer to an array of n unsigned long variables that will
 receive the actual sizes (in bytes) of each transformed JPEG image.  If
 <tt>dstBufs[i]</tt> points to a pre-allocated buffer, then
 <tt>dstSizes[i]</tt> should be set to the size of the buffer.  Upon return,
 <tt>dstSizes[i]</tt> will contain the size of the JPEG image (in bytes.)

 @param transforms pointer to an array of n #tjtransform structures, each of
 which specifies the transform parameters and/or cropping region for the
 corresponding transformed output image.

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjInitTransform">
 Create a new TurboJPEG transformer instance.

 @return a handle to the newly-created instance, or NULL if an error
 occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecodeYUVPlanes(System.Void*,System.Byte**,System.Int32*,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 Decode a set of Y, U (Cb), and V (Cr) image planes into an RGB or grayscale
 image.  This function uses the accelerated color conversion routines in the
 underlying codec but does not execute any of the other steps in the JPEG
 decompression process.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
 (or just a Y plane, if decoding a grayscale image) that contain a YUV image
 to be decoded.  These planes can be contiguous or non-contiguous in memory.
 The size of each plane should match the value returned by #tjPlaneSizeYUV()
 for the given image width, height, strides, and level of chrominance
 subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes" for more
 details.  These image planes are not modified.

 @param strides an array of integers, each specifying the number of bytes per
 line in the corresponding plane of the YUV source image.  Setting the stride
 for any plane to 0 is the same as setting it to the plane width (see
 @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
 the strides for all planes will be set to their respective plane widths.
 You can adjust the strides in order to specify an arbitrary amount of line
 padding in each plane or to decode a subregion of a larger YUV planar image.

 @param subsamp the level of chrominance subsampling used in the YUV source
 image (see @ref TJSAMP "Chrominance subsampling options".)

 @param dstBuf pointer to an image buffer that will receive the decoded
 image.  This buffer should normally be <tt>pitch * height</tt> bytes in
 size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
 specific region of a larger buffer.

 @param width width (in pixels) of the source and destination images

 @param pitch bytes per line in the destination image.  Normally, this should
 be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
 unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
 of the destination image should be padded to the nearest 32-bit boundary, as
 is the case for Windows bitmaps.  You can also be clever and use the pitch
 parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
 of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.

 @param height height (in pixels) of the source and destination images

 @param pixelFormat pixel format of the destination image (see @ref TJPF
 "Pixel formats".)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecodeYUV(System.Void*,System.Byte*,System.Int32,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 Decode a YUV planar image into an RGB or grayscale image.  This function
 uses the accelerated color conversion routines in the underlying
 codec but does not execute any of the other steps in the JPEG decompression
 process.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param srcBuf pointer to an image buffer containing a YUV planar image to be
 decoded.  The size of this buffer should match the value returned by
 #tjBufSizeYUV2() for the given image width, height, padding, and level of
 chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
 stored sequentially in the source buffer (refer to @ref YUVnotes
 "YUV Image Format Notes".)  This buffer is not modified.

 @param pad Use this parameter to specify that the width of each line in each
 plane of the YUV source image is padded to the nearest multiple of this
 number of bytes (must be a power of 2.)

 @param subsamp the level of chrominance subsampling used in the YUV source
 image (see @ref TJSAMP "Chrominance subsampling options".)

 @param dstBuf pointer to an image buffer that will receive the decoded
 image.  This buffer should normally be <tt>pitch * height</tt> bytes in
 size, but the <tt>dstBuf</tt> pointer can also be used to decode into a
 specific region of a larger buffer.

 @param width width (in pixels) of the source and destination images

 @param pitch bytes per line in the destination image.  Normally, this should
 be <tt>width * #tjPixelSize[pixelFormat]</tt> if the destination image is
 unpadded, or <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line
 of the destination image should be padded to the nearest 32-bit boundary, as
 is the case for Windows bitmaps.  You can also be clever and use the pitch
 parameter to skip lines, etc.  Setting this parameter to 0 is the equivalent
 of setting it to <tt>width * #tjPixelSize[pixelFormat]</tt>.

 @param height height (in pixels) of the source and destination images

 @param pixelFormat pixel format of the destination image (see @ref TJPF
 "Pixel formats".)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecompressToYUVPlanes(System.Void*,System.Byte*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Byte**,System.Int32,System.Int32*,System.Int32,System.Int32)">
 Decompress a JPEG image into separate Y, U (Cb), and V (Cr) image
 planes.  This function performs JPEG decompression but leaves out the color
 conversion step, so a planar YUV image is generated instead of an RGB image.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param jpegBuf pointer to a buffer containing the JPEG image to decompress.
 This buffer is not modified.

 @param jpegSize size of the JPEG image (in bytes)

 @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
 (or just a Y plane, if decompressing a grayscale image) that will receive
 the YUV image.  These planes can be contiguous or non-contiguous in memory.
 Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based
 on the scaled image width, scaled image height, strides, and level of
 chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
 for more details.

 @param width desired width (in pixels) of the YUV image.  If this is
 different than the width of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired width.  If <tt>width</tt> is
 set to 0, then only the height will be considered when determining the
 scaled image size.  If the scaled width is not an even multiple of the MCU
 block width (see #tjMCUWidth), then an intermediate buffer copy will be
 performed within TurboJPEG.

 @param strides an array of integers, each specifying the number of bytes per
 line in the corresponding plane of the output image.  Setting the stride for
 any plane to 0 is the same as setting it to the scaled plane width (see
 @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
 the strides for all planes will be set to their respective scaled plane
 widths.  You can adjust the strides in order to add an arbitrary amount of
 line padding to each plane or to decompress the JPEG image into a subregion
 of a larger YUV planar image.

 @param height desired height (in pixels) of the YUV image.  If this is
 different than the height of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired height.  If <tt>height</tt>
 is set to 0, then only the width will be considered when determining the
 scaled image size.  If the scaled height is not an even multiple of the MCU
 block height (see #tjMCUHeight), then an intermediate buffer copy will be
 performed within TurboJPEG.

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecompressToYUV2(System.Void*,System.Byte*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32)">
 Decompress a JPEG image to a YUV planar image.  This function performs JPEG
 decompression but leaves out the color conversion step, so a planar YUV
 image is generated instead of an RGB image.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param jpegBuf pointer to a buffer containing the JPEG image to decompress.
 This buffer is not modified.

 @param jpegSize size of the JPEG image (in bytes)

 @param dstBuf pointer to an image buffer that will receive the YUV image.
 Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
 on the image width, height, padding, and level of subsampling.  The Y,
 U (Cb), and V (Cr) image planes will be stored sequentially in the buffer
 (refer to @ref YUVnotes "YUV Image Format Notes".)

 @param width desired width (in pixels) of the YUV image.  If this is
 different than the width of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired width.  If <tt>width</tt> is
 set to 0, then only the height will be considered when determining the
 scaled image size.  If the scaled width is not an even multiple of the MCU
 block width (see #tjMCUWidth), then an intermediate buffer copy will be
 performed within TurboJPEG.

 @param pad the width of each line in each plane of the YUV image will be
 padded to the nearest multiple of this number of bytes (must be a power of
 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
 4.

 @param height desired height (in pixels) of the YUV image.  If this is
 different than the height of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired height.  If <tt>height</tt>
 is set to 0, then only the width will be considered when determining the
 scaled image size.  If the scaled height is not an even multiple of the MCU
 block height (see #tjMCUHeight), then an intermediate buffer copy will be
 performed within TurboJPEG.

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecompress2(System.Void*,System.Byte*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 Decompress a JPEG image to an RGB, grayscale, or CMYK image.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param jpegBuf pointer to a buffer containing the JPEG image to decompress.
 This buffer is not modified.

 @param jpegSize size of the JPEG image (in bytes)

 @param dstBuf pointer to an image buffer that will receive the decompressed
 image.  This buffer should normally be <tt>pitch * scaledHeight</tt> bytes
 in size, where <tt>scaledHeight</tt> can be determined by calling
 #TJSCALED() with the JPEG image height and one of the scaling factors
 returned by #tjGetScalingFactors().  The <tt>dstBuf</tt> pointer may also be
 used to decompress into a specific region of a larger buffer.

 @param width desired width (in pixels) of the destination image.  If this is
 different than the width of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired width.  If <tt>width</tt> is
 set to 0, then only the height will be considered when determining the
 scaled image size.

 @param pitch bytes per line in the destination image.  Normally, this is
 <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt> if the decompressed image
 is unpadded, else <tt>#TJPAD(scaledWidth * #tjPixelSize[pixelFormat])</tt>
 if each line of the decompressed image is padded to the nearest 32-bit
 boundary, as is the case for Windows bitmaps.  (NOTE: <tt>scaledWidth</tt>
 can be determined by calling #TJSCALED() with the JPEG image width and one
 of the scaling factors returned by #tjGetScalingFactors().)  You can also be
 clever and use the pitch parameter to skip lines, etc.  Setting this
 parameter to 0 is the equivalent of setting it to
 <tt>scaledWidth * #tjPixelSize[pixelFormat]</tt>.

 @param height desired height (in pixels) of the destination image.  If this
 is different than the height of the JPEG image being decompressed, then
 TurboJPEG will use scaling in the JPEG decompressor to generate the largest
 possible image that will fit within the desired height.  If <tt>height</tt>
 is set to 0, then only the width will be considered when determining the
 scaled image size.

 @param pixelFormat pixel format of the destination image (see @ref
 TJPF "Pixel formats".)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjGetScalingFactors(System.Int32*)">
 Returns a list of fractional scaling factors that the JPEG decompressor in
 this implementation of TurboJPEG supports.

 @param numscalingfactors pointer to an integer variable that will receive
 the number of elements in the list

 @return a pointer to a list of fractional scaling factors, or NULL if an
 error is encountered (see #tjGetErrorStr().)

</member>
        <member name="M:tjDecompressHeader3(System.Void*,System.Byte*,System.UInt32!System.Runtime.CompilerServices.IsLong,System.Int32*,System.Int32*,System.Int32*,System.Int32*)">
 Retrieve information about a JPEG image without decompressing it.

 @param handle a handle to a TurboJPEG decompressor or transformer instance

 @param jpegBuf pointer to a buffer containing a JPEG image.  This buffer is
 not modified.

 @param jpegSize size of the JPEG image (in bytes)

 @param width pointer to an integer variable that will receive the width (in
 pixels) of the JPEG image

 @param height pointer to an integer variable that will receive the height
 (in pixels) of the JPEG image

 @param jpegSubsamp pointer to an integer variable that will receive the
 level of chrominance subsampling used when the JPEG image was compressed
 (see @ref TJSAMP "Chrominance subsampling options".)

 @param jpegColorspace pointer to an integer variable that will receive one
 of the JPEG colorspace constants, indicating the colorspace of the JPEG
 image (see @ref TJCS "JPEG colorspaces".)

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjInitDecompress">
 Create a TurboJPEG decompressor instance.

 @return a handle to the newly-created instance, or NULL if an error
 occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjEncodeYUVPlanes(System.Void*,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte**,System.Int32*,System.Int32,System.Int32)">
 Encode an RGB or grayscale image into separate Y, U (Cb), and V (Cr) image
 planes.  This function uses the accelerated color conversion routines in the
 underlying codec but does not execute any of the other steps in the JPEG
 compression process.

 @param handle a handle to a TurboJPEG compressor or transformer instance

 @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
 to be encoded.  This buffer is not modified.

 @param width width (in pixels) of the source image

 @param pitch bytes per line in the source image.  Normally, this should be
 <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
 <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
 is padded to the nearest 32-bit boundary, as is the case for Windows
 bitmaps.  You can also be clever and use this parameter to skip lines, etc.
 Setting this parameter to 0 is the equivalent of setting it to
 <tt>width * #tjPixelSize[pixelFormat]</tt>.

 @param height height (in pixels) of the source image

 @param pixelFormat pixel format of the source image (see @ref TJPF
 "Pixel formats".)

 @param dstPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
 (or just a Y plane, if generating a grayscale image) that will receive the
 encoded image.  These planes can be contiguous or non-contiguous in memory.
 Use #tjPlaneSizeYUV() to determine the appropriate size for each plane based
 on the image width, height, strides, and level of chrominance subsampling.
 Refer to @ref YUVnotes "YUV Image Format Notes" for more details.

 @param strides an array of integers, each specifying the number of bytes per
 line in the corresponding plane of the output image.  Setting the stride for
 any plane to 0 is the same as setting it to the plane width (see
 @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
 the strides for all planes will be set to their respective plane widths.
 You can adjust the strides in order to add an arbitrary amount of line
 padding to each plane or to encode an RGB or grayscale image into a
 subregion of a larger YUV planar image.

 @param subsamp the level of chrominance subsampling to be used when
 generating the YUV image (see @ref TJSAMP
 "Chrominance subsampling options".)  To generate images suitable for X
 Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
 image compatible with the I420 (AKA "YUV420P") format.

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjEncodeYUV3(System.Void*,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte*,System.Int32,System.Int32,System.Int32)">
 Encode an RGB or grayscale image into a YUV planar image.  This function
 uses the accelerated color conversion routines in the underlying
 codec but does not execute any of the other steps in the JPEG compression
 process.

 @param handle a handle to a TurboJPEG compressor or transformer instance

 @param srcBuf pointer to an image buffer containing RGB or grayscale pixels
 to be encoded.  This buffer is not modified.

 @param width width (in pixels) of the source image

 @param pitch bytes per line in the source image.  Normally, this should be
 <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
 <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
 is padded to the nearest 32-bit boundary, as is the case for Windows
 bitmaps.  You can also be clever and use this parameter to skip lines, etc.
 Setting this parameter to 0 is the equivalent of setting it to
 <tt>width * #tjPixelSize[pixelFormat]</tt>.

 @param height height (in pixels) of the source image

 @param pixelFormat pixel format of the source image (see @ref TJPF
 "Pixel formats".)

 @param dstBuf pointer to an image buffer that will receive the YUV image.
 Use #tjBufSizeYUV2() to determine the appropriate size for this buffer based
 on the image width, height, padding, and level of chrominance subsampling.
 The Y, U (Cb), and V (Cr) image planes will be stored sequentially in the
 buffer (refer to @ref YUVnotes "YUV Image Format Notes".)

 @param pad the width of each line in each plane of the YUV image will be
 padded to the nearest multiple of this number of bytes (must be a power of
 2.)  To generate images suitable for X Video, <tt>pad</tt> should be set to
 4.

 @param subsamp the level of chrominance subsampling to be used when
 generating the YUV image (see @ref TJSAMP
 "Chrominance subsampling options".)  To generate images suitable for X
 Video, <tt>subsamp</tt> should be set to @ref TJSAMP_420.  This produces an
 image compatible with the I420 (AKA "YUV420P") format.

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjPlaneHeight(System.Int32,System.Int32,System.Int32)">
 The plane height of a YUV image plane with the given parameters.  Refer to
 @ref YUVnotes "YUV Image Format Notes" for a description of plane height.

 @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)

 @param height height (in pixels) of the YUV image

 @param subsamp level of chrominance subsampling in the image (see
 @ref TJSAMP "Chrominance subsampling options".)

 @return the plane height of a YUV image plane with the given parameters, or
 -1 if the arguments are out of bounds.

</member>
        <member name="M:tjPlaneWidth(System.Int32,System.Int32,System.Int32)">
 The plane width of a YUV image plane with the given parameters.  Refer to
 @ref YUVnotes "YUV Image Format Notes" for a description of plane width.

 @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)

 @param width width (in pixels) of the YUV image

 @param subsamp level of chrominance subsampling in the image (see
 @ref TJSAMP "Chrominance subsampling options".)

 @return the plane width of a YUV image plane with the given parameters, or
 -1 if the arguments are out of bounds.

</member>
        <member name="M:tjPlaneSizeYUV(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
 The size of the buffer (in bytes) required to hold a YUV image plane with
 the given parameters.

 @param componentID ID number of the image plane (0 = Y, 1 = U/Cb, 2 = V/Cr)

 @param width width (in pixels) of the YUV image.  NOTE: this is the width of
 the whole image, not the plane width.

 @param stride bytes per line in the image plane.  Setting this to 0 is the
 equivalent of setting it to the plane width.

 @param height height (in pixels) of the YUV image.  NOTE: this is the height
 of the whole image, not the plane height.

 @param subsamp level of chrominance subsampling in the image (see
 @ref TJSAMP "Chrominance subsampling options".)

 @return the size of the buffer (in bytes) required to hold the YUV image
 plane, or -1 if the arguments are out of bounds.

</member>
        <member name="M:tjBufSizeYUV2(System.Int32,System.Int32,System.Int32,System.Int32)">
 The size of the buffer (in bytes) required to hold a YUV planar image with
 the given parameters.

 @param width width (in pixels) of the image

 @param pad the width of each line in each plane of the image is padded to
 the nearest multiple of this number of bytes (must be a power of 2.)

 @param height height (in pixels) of the image

 @param subsamp level of chrominance subsampling in the image (see
 @ref TJSAMP "Chrominance subsampling options".)

 @return the size of the buffer (in bytes) required to hold the image, or
 -1 if the arguments are out of bounds.

</member>
        <member name="M:tjBufSize(System.Int32,System.Int32,System.Int32)">
 The maximum size of the buffer (in bytes) required to hold a JPEG image with
 the given parameters.  The number of bytes returned by this function is
 larger than the size of the uncompressed source image.  The reason for this
 is that the JPEG format uses 16-bit coefficients, and it is thus possible
 for a very high-quality JPEG image with very high-frequency content to
 expand rather than compress when converted to the JPEG format.  Such images
 represent a very rare corner case, but since there is no way to predict the
 size of a JPEG image prior to compression, the corner case has to be
 handled.

 @param width width (in pixels) of the image

 @param height height (in pixels) of the image

 @param jpegSubsamp the level of chrominance subsampling to be used when
 generating the JPEG image (see @ref TJSAMP
 "Chrominance subsampling options".)

 @return the maximum size of the buffer (in bytes) required to hold the
 image, or -1 if the arguments are out of bounds.

</member>
        <member name="M:tjCompressFromYUVPlanes(System.Void*,System.Byte**,System.Int32,System.Int32*,System.Int32,System.Int32,System.Byte**,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Int32,System.Int32)">
 Compress a set of Y, U (Cb), and V (Cr) image planes into a JPEG image.

 @param handle a handle to a TurboJPEG compressor or transformer instance

 @param srcPlanes an array of pointers to Y, U (Cb), and V (Cr) image planes
 (or just a Y plane, if compressing a grayscale image) that contain a YUV
 image to be compressed.  These planes can be contiguous or non-contiguous in
 memory.  The size of each plane should match the value returned by
 #tjPlaneSizeYUV() for the given image width, height, strides, and level of
 chrominance subsampling.  Refer to @ref YUVnotes "YUV Image Format Notes"
 for more details.  These image planes are not modified.

 @param width width (in pixels) of the source image.  If the width is not an
 even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
 buffer copy will be performed within TurboJPEG.

 @param strides an array of integers, each specifying the number of bytes per
 line in the corresponding plane of the YUV source image.  Setting the stride
 for any plane to 0 is the same as setting it to the plane width (see
 @ref YUVnotes "YUV Image Format Notes".)  If <tt>strides</tt> is NULL, then
 the strides for all planes will be set to their respective plane widths.
 You can adjust the strides in order to specify an arbitrary amount of line
 padding in each plane or to create a JPEG image from a subregion of a larger
 YUV planar image.

 @param height height (in pixels) of the source image.  If the height is not
 an even multiple of the MCU block height (see #tjMCUHeight), then an
 intermediate buffer copy will be performed within TurboJPEG.

 @param subsamp the level of chrominance subsampling used in the source
 image (see @ref TJSAMP "Chrominance subsampling options".)

 @param jpegBuf address of a pointer to an image buffer that will receive the
 JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
 accommodate the size of the JPEG image.  Thus, you can choose to:
 -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
 let TurboJPEG grow the buffer as needed,
 -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
 for you, or
 -# pre-allocate the buffer to a "worst case" size determined by calling
 #tjBufSize().  This should ensure that the buffer never has to be
 re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)
 .
 If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
 pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
 you should always check <tt>*jpegBuf</tt> upon return from this function, as
 it may have changed.

 @param jpegSize pointer to an unsigned long variable that holds the size of
 the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
 buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
 Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
 bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
 reused from a previous call to one of the JPEG compression functions, then
 <tt>*jpegSize</tt> is ignored.

 @param jpegQual the image quality of the generated JPEG image (1 = worst,
 100 = best)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjCompressFromYUV(System.Void*,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte**,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Int32,System.Int32)">
 Compress a YUV planar image into a JPEG image.

 @param handle a handle to a TurboJPEG compressor or transformer instance

 @param srcBuf pointer to an image buffer containing a YUV planar image to be
 compressed.  The size of this buffer should match the value returned by
 #tjBufSizeYUV2() for the given image width, height, padding, and level of
 chrominance subsampling.  The Y, U (Cb), and V (Cr) image planes should be
 stored sequentially in the source buffer (refer to @ref YUVnotes
 "YUV Image Format Notes".)  This buffer is not modified.

 @param width width (in pixels) of the source image.  If the width is not an
 even multiple of the MCU block width (see #tjMCUWidth), then an intermediate
 buffer copy will be performed within TurboJPEG.

 @param pad the line padding used in the source image.  For instance, if each
 line in each plane of the YUV image is padded to the nearest multiple of 4
 bytes, then <tt>pad</tt> should be set to 4.

 @param height height (in pixels) of the source image.  If the height is not
 an even multiple of the MCU block height (see #tjMCUHeight), then an
 intermediate buffer copy will be performed within TurboJPEG.

 @param subsamp the level of chrominance subsampling used in the source
 image (see @ref TJSAMP "Chrominance subsampling options".)

 @param jpegBuf address of a pointer to an image buffer that will receive the
 JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer to
 accommodate the size of the JPEG image.  Thus, you can choose to:
 -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
 let TurboJPEG grow the buffer as needed,
 -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
 for you, or
 -# pre-allocate the buffer to a "worst case" size determined by calling
 #tjBufSize().  This should ensure that the buffer never has to be
 re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)
 .
 If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
 pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
 you should always check <tt>*jpegBuf</tt> upon return from this function, as
 it may have changed.

 @param jpegSize pointer to an unsigned long variable that holds the size of
 the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
 buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
 Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
 bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
 reused from a previous call to one of the JPEG compression functions, then
 <tt>*jpegSize</tt> is ignored.

 @param jpegQual the image quality of the generated JPEG image (1 = worst,
 100 = best)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjCompress2(System.Void*,System.Byte*,System.Int32,System.Int32,System.Int32,System.Int32,System.Byte**,System.UInt32!System.Runtime.CompilerServices.IsLong*,System.Int32,System.Int32,System.Int32)">
 Compress an RGB, grayscale, or CMYK image into a JPEG image.

 @param handle a handle to a TurboJPEG compressor or transformer instance

 @param srcBuf pointer to an image buffer containing RGB, grayscale, or
 CMYK pixels to be compressed.  This buffer is not modified.

 @param width width (in pixels) of the source image

 @param pitch bytes per line in the source image.  Normally, this should be
 <tt>width * #tjPixelSize[pixelFormat]</tt> if the image is unpadded, or
 <tt>#TJPAD(width * #tjPixelSize[pixelFormat])</tt> if each line of the image
 is padded to the nearest 32-bit boundary, as is the case for Windows
 bitmaps.  You can also be clever and use this parameter to skip lines, etc.
 Setting this parameter to 0 is the equivalent of setting it to
 <tt>width * #tjPixelSize[pixelFormat]</tt>.

 @param height height (in pixels) of the source image

 @param pixelFormat pixel format of the source image (see @ref TJPF
 "Pixel formats".)

 @param jpegBuf address of a pointer to an image buffer that will receive the
 JPEG image.  TurboJPEG has the ability to reallocate the JPEG buffer
 to accommodate the size of the JPEG image.  Thus, you can choose to:
 -# pre-allocate the JPEG buffer with an arbitrary size using #tjAlloc() and
 let TurboJPEG grow the buffer as needed,
 -# set <tt>*jpegBuf</tt> to NULL to tell TurboJPEG to allocate the buffer
 for you, or
 -# pre-allocate the buffer to a "worst case" size determined by calling
 #tjBufSize().  This should ensure that the buffer never has to be
 re-allocated (setting #TJFLAG_NOREALLOC guarantees this.)
 .
 If you choose option 1, <tt>*jpegSize</tt> should be set to the size of your
 pre-allocated buffer.  In any case, unless you have set #TJFLAG_NOREALLOC,
 you should always check <tt>*jpegBuf</tt> upon return from this function, as
 it may have changed.

 @param jpegSize pointer to an unsigned long variable that holds the size of
 the JPEG image buffer.  If <tt>*jpegBuf</tt> points to a pre-allocated
 buffer, then <tt>*jpegSize</tt> should be set to the size of the buffer.
 Upon return, <tt>*jpegSize</tt> will contain the size of the JPEG image (in
 bytes.)  If <tt>*jpegBuf</tt> points to a JPEG image buffer that is being
 reused from a previous call to one of the JPEG compression functions, then
 <tt>*jpegSize</tt> is ignored.

 @param jpegSubsamp the level of chrominance subsampling to be used when
 generating the JPEG image (see @ref TJSAMP
 "Chrominance subsampling options".)

 @param jpegQual the image quality of the generated JPEG image (1 = worst,
 100 = best)

 @param flags the bitwise OR of one or more of the @ref TJFLAG_BOTTOMUP
 "flags"

 @return 0 if successful, or -1 if an error occurred (see #tjGetErrorStr().)

</member>
        <member name="M:tjInitCompress">
Pad the given width to the nearest 32-bit boundary

Compute the scaled value of <tt>dimension</tt> using the given scaling
factor.  This macro performs the integer equivalent of <tt>ceil(dimension *
scalingFactor)</tt>.

 Create a TurboJPEG compressor instance.

 @return a handle to the newly-created instance, or NULL if an error
 occurred (see #tjGetErrorStr().)

</member>
        <member name="D:tjhandle">
TurboJPEG instance handle

</member>
        <member name="F:tjtransform.data">
Arbitrary data that can be accessed within the body of the callback
function

</member>
        <member name="F:tjtransform.options">
The bitwise OR of one of more of the @ref TJXOPT_CROP "transform options"

</member>
        <member name="F:tjtransform.op">
One of the @ref TJXOP "transform operations"

</member>
        <member name="F:tjtransform.r">
Cropping region

</member>
        <member name="T:tjtransform">
Lossless transform


 A callback function that can be used to modify the DCT coefficients
 after they are losslessly transformed but before they are transcoded to a
 new JPEG image.  This allows for custom filters or other transformations
 to be applied in the frequency domain.

 @param coeffs pointer to an array of transformed DCT coefficients.  (NOTE:
 this pointer is not guaranteed to be valid once the callback returns, so
 applications wishing to hand off the DCT coefficients to another function
 or library should make a copy of them within the body of the callback.)

 @param arrayRegion #tjregion structure containing the width and height of
 the array pointed to by <tt>coeffs</tt> as well as its offset relative to
 the component plane.  TurboJPEG implementations may choose to split each
 component plane into multiple DCT coefficient arrays and call the callback
 function once for each array.

 @param planeRegion #tjregion structure containing the width and height of
 the component plane to which <tt>coeffs</tt> belongs

 @param componentID ID number of the component plane to which
 <tt>coeffs</tt> belongs (Y, Cb, and Cr have, respectively, ID's of 0, 1,
 and 2 in typical JPEG images.)

 @param transformID ID number of the transformed image to which
 <tt>coeffs</tt> belongs.  This is the same as the index of the transform
 in the <tt>transforms</tt> array that was passed to #tjTransform().

 @param transform a pointer to a #tjtransform structure that specifies the
 parameters and/or cropping region for this transform

 @return 0 if the callback was successful, or -1 if an error occurred.

</member>
        <member name="T:TJXOP">
The uncompressed source/destination image is stored in bottom-up (Windows,
OpenGL) order, not top-down (X11) order.

When decompressing an image that was compressed using chrominance
subsampling, use the fastest chrominance upsampling algorithm available in
the underlying codec.  The default is to use smooth upsampling, which
creates a smooth transition between neighboring chrominance components in
order to reduce upsampling artifacts in the decompressed image.

Disable buffer (re)allocation.  If passed to #tjCompress2() or
#tjTransform(), this flag will cause those functions to generate an error if
the JPEG image buffer is invalid or too small rather than attempting to
allocate or reallocate that buffer.  This reproduces the behavior of earlier
versions of TurboJPEG.

Use the fastest DCT/IDCT algorithm available in the underlying codec.  The
default if this flag is not specified is implementation-specific.  For
example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
algorithm by default when compressing, because this has been shown to have
only a very slight effect on accuracy, but it uses the accurate algorithm
when decompressing, because this has been shown to have a larger effect.

Use the most accurate DCT/IDCT algorithm available in the underlying codec.
The default if this flag is not specified is implementation-specific.  For
example, the implementation of TurboJPEG for libjpeg[-turbo] uses the fast
algorithm by default when compressing, because this has been shown to have
only a very slight effect on accuracy, but it uses the accurate algorithm
when decompressing, because this has been shown to have a larger effect.

The number of transform operations

Transform operations for #tjTransform()

</member>
        <member name="F:TJXOP_ROT270">
Rotate image counter-clockwise by 90 degrees.  This transform is imperfect
if there are any partial MCU blocks on the right edge (see
#TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_ROT180">
Rotate image 180 degrees.  This transform is imperfect if there are any
partial MCU blocks in the image (see #TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_ROT90">
Rotate image clockwise by 90 degrees.  This transform is imperfect if
there are any partial MCU blocks on the bottom edge (see
#TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_TRANSVERSE">
Transverse transpose image (flip/mirror along upper right to lower left
axis.)  This transform is imperfect if there are any partial MCU blocks in
the image (see #TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_TRANSPOSE">
Transpose image (flip/mirror along upper left to lower right axis.)  This
transform is always perfect.

</member>
        <member name="F:TJXOP_VFLIP">
Flip (mirror) image vertically.  This transform is imperfect if there are
any partial MCU blocks on the bottom edge (see #TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_HFLIP">
Flip (mirror) image horizontally.  This transform is imperfect if there
are any partial MCU blocks on the right edge (see #TJXOPT_PERFECT.)

</member>
        <member name="F:TJXOP_NONE">
Do not transform the position of the image pixels

</member>
        <member name="T:TJCS">
The number of JPEG colorspaces

JPEG colorspaces

</member>
        <member name="F:TJCS_YCCK">
YCCK colorspace.  YCCK (AKA "YCbCrK") is not an absolute colorspace but
rather a mathematical transformation of CMYK designed solely for storage
and transmission.  It is to CMYK as YCbCr is to RGB.  CMYK pixels can be
reversibly transformed into YCCK, and as with YCbCr, the chrominance
components in the YCCK pixels can be subsampled without incurring major
perceptual loss.  YCCK JPEG images can only be compressed from and
decompressed to CMYK pixels.

</member>
        <member name="F:TJCS_CMYK">
CMYK colorspace.  When compressing the JPEG image, the C, M, Y, and K
components in the source image are reordered into image planes, but no
colorspace conversion or subsampling is performed.  CMYK JPEG images can
only be decompressed to CMYK pixels.

</member>
        <member name="F:TJCS_GRAY">
Grayscale colorspace.  The JPEG image retains only the luminance data (Y
component), and any color data from the source image is discarded.
Grayscale JPEG images can be compressed from and decompressed to any of
the extended RGB pixel formats or grayscale, or they can be decompressed
to YUV planar images.

</member>
        <member name="F:TJCS_RGB">
RGB colorspace.  When compressing the JPEG image, the R, G, and B
components in the source image are reordered into image planes, but no
colorspace conversion or subsampling is performed.  RGB JPEG images can be
decompressed to any of the extended RGB pixel formats or grayscale, but
they cannot be decompressed to YUV images.

</member>
        <member name="T:TJPF">
The number of pixel formats

Pixel formats

</member>
        <member name="F:TJPF_CMYK">
CMYK pixel format.  Unlike RGB, which is an additive color model used
primarily for display, CMYK (Cyan/Magenta/Yellow/Key) is a subtractive
color model used primarily for printing.  In the CMYK color model, the
value of each color component typically corresponds to an amount of cyan,
magenta, yellow, or black ink that is applied to a white background.  In
order to convert between CMYK and RGB, it is necessary to use a color
management system (CMS.)  A CMS will attempt to map colors within the
printer's gamut to perceptually similar colors in the display's gamut and
vice versa, but the mapping is typically not 1:1 or reversible, nor can it
be defined with a simple formula.  Thus, such a conversion is out of scope
for a codec library.  However, the TurboJPEG API allows for compressing
CMYK pixels into a YCCK JPEG image (see #TJCS_YCCK) and decompressing YCCK
JPEG images into CMYK pixels.

</member>
        <member name="F:TJPF_ARGB">
ARGB pixel format.  This is the same as @ref TJPF_XRGB, except that when
decompressing, the X component is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.

</member>
        <member name="F:TJPF_ABGR">
ABGR pixel format.  This is the same as @ref TJPF_XBGR, except that when
decompressing, the X component is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.

</member>
        <member name="F:TJPF_BGRA">
BGRA pixel format.  This is the same as @ref TJPF_BGRX, except that when
decompressing, the X component is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.

</member>
        <member name="F:TJPF_RGBA">
RGBA pixel format.  This is the same as @ref TJPF_RGBX, except that when
decompressing, the X component is guaranteed to be 0xFF, which can be
interpreted as an opaque alpha channel.

</member>
        <member name="F:TJPF_GRAY">
Grayscale pixel format.  Each 1-byte pixel represents a luminance
(brightness) level from 0 to 255.

</member>
        <member name="F:TJPF_XRGB">
XRGB pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order B, G, R from highest to lowest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.

</member>
        <member name="F:TJPF_XBGR">
XBGR pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order R, G, B from highest to lowest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.

</member>
        <member name="F:TJPF_BGRX">
BGRX pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order B, G, R from lowest to highest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.

</member>
        <member name="F:TJPF_RGBX">
RGBX pixel format.  The red, green, and blue components in the image are
stored in 4-byte pixels in the order R, G, B from lowest to highest byte
address within each pixel.  The X component is ignored when compressing
and undefined when decompressing.

</member>
        <member name="F:TJPF_BGR">
BGR pixel format.  The red, green, and blue components in the image are
stored in 3-byte pixels in the order B, G, R from lowest to highest byte
address within each pixel.

</member>
        <member name="F:TJPF_RGB">
RGB pixel format.  The red, green, and blue components in the image are
stored in 3-byte pixels in the order R, G, B from lowest to highest byte
address within each pixel.

</member>
        <member name="T:TJSAMP">
 @addtogroup TurboJPEG
 TurboJPEG API.  This API provides an interface for generating, decoding, and
 transforming planar YUV and JPEG images in memory.

 @anchor YUVnotes
 YUV Image Format Notes
 ----------------------
 Technically, the JPEG format uses the YCbCr colorspace (which is technically
 not a colorspace but a color transform), but per the convention of the
 digital video community, the TurboJPEG API uses "YUV" to refer to an image
 format consisting of Y, Cb, and Cr image planes.

 Each plane is simply a 2D array of bytes, each byte representing the value
 of one of the components (Y, Cb, or Cr) at a particular location in the
 image.  The width and height of each plane are determined by the image
 width, height, and level of chrominance subsampling.   The luminance plane
 width is the image width padded to the nearest multiple of the horizontal
 subsampling factor (2 in the case of 4:2:0 and 4:2:2, 4 in the case of
 4:1:1, 1 in the case of 4:4:4 or grayscale.)  Similarly, the luminance plane
 height is the image height padded to the nearest multiple of the vertical
 subsampling factor (2 in the case of 4:2:0 or 4:4:0, 1 in the case of 4:4:4
 or grayscale.)  This is irrespective of any additional padding that may be
 specified as an argument to the various YUV functions.  The chrominance
 plane width is equal to the luminance plane width divided by the horizontal
 subsampling factor, and the chrominance plane height is equal to the
 luminance plane height divided by the vertical subsampling factor.

 For example, if the source image is 35 x 35 pixels and 4:2:2 subsampling is
 used, then the luminance plane would be 36 x 35 bytes, and each of the
 chrominance planes would be 18 x 35 bytes.  If you specify a line padding of
 4 bytes on top of this, then the luminance plane would be 36 x 35 bytes, and
 each of the chrominance planes would be 20 x 35 bytes.

 @{

The number of chrominance subsampling options

Chrominance subsampling options.
When pixels are converted from RGB to YCbCr (see #TJCS_YCbCr) or from CMYK
to YCCK (see #TJCS_YCCK) as part of the JPEG compression process, some of
the Cb and Cr (chrominance) components can be discarded or averaged together
to produce a smaller image with little perceptible loss of image clarity
(the human eye is more sensitive to small changes in brightness than to
small changes in color.)  This is called "chrominance subsampling".

</member>
        <member name="F:TJSAMP_411">
 4:1:1 chrominance subsampling.  The JPEG or YUV image will contain one
 chrominance component for every 4x1 block of pixels in the source image.
 JPEG images compressed with 4:1:1 subsampling will be almost exactly the
 same size as those compressed with 4:2:0 subsampling, and in the
 aggregate, both subsampling methods produce approximately the same
 perceptual quality.  However, 4:1:1 is better able to reproduce sharp
 horizontal features.

 @note 4:1:1 subsampling is not fully accelerated in libjpeg-turbo.

</member>
        <member name="F:TJSAMP_440">
 4:4:0 chrominance subsampling.  The JPEG or YUV image will contain one
 chrominance component for every 1x2 block of pixels in the source image.

 @note 4:4:0 subsampling is not fully accelerated in libjpeg-turbo.

</member>
        <member name="F:TJSAMP_GRAY">
Grayscale.  The JPEG or YUV image will contain no chrominance components.

</member>
        <member name="F:TJSAMP_420">
4:2:0 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 2x2 block of pixels in the source image.

</member>
        <member name="F:TJSAMP_422">
4:2:2 chrominance subsampling.  The JPEG or YUV image will contain one
chrominance component for every 2x1 block of pixels in the source image.

</member>
        <member name="F:TJSAMP_444">
4:4:4 chrominance subsampling (no chrominance subsampling).  The JPEG or
YUV image will contain one chrominance component for every pixel in the
source image.

</member>
        <member name="T:clix.Encoding">
            <summary>Encoding types for strings</summary>
        </member>
        <member name="F:E_UTF16">
            <summary>UTF-16 encoding</summary>
            <remarks>
  This is the suggested encoding for marshaling and the native encoding of .NET strings.
  It is similar to UTF-8 but uses a minimum of two bytes per character, making the number
  of bytes required for a given string better predictable. Be aware, however, that UTF-16
  can still use more than two bytes for a character, so std::wstring::length() might not
  reflect the actual length of the string.
</remarks>
        </member>
        <member name="F:E_UTF8">
            <summary>UTF-8 encoding</summary>
            <remarks>
  This is the encoding commonly used for multilingual C++ strings. All ASCII characters
  (0-127) will be represented as single bytes. Be aware that UTF-8 uses more than one
  byte for extended characters, so std::string::length() might not reflect the actual
  length of the string in characters if it contains any non-ASCII characters.
</remarks>
        </member>
        <member name="F:E_ANSI">
            <summary>ANSI encoding</summary>
            <remarks>
  This is the default encoding you've most likely been using all around in C++. ANSI
  means 8 Bit encoding with character codes depending on the system's selected code page.
</remarks>
        </member>
        <!-- Discarding badly formed XML document comment for member 'F:TJCS_YCbCr'. -->
        <!-- Discarding badly formed XML document comment for member 'F:TJCS_YCbCr'. -->
    </members>
</doc>